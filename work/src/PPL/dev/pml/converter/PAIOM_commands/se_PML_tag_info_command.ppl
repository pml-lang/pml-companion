// SPDX-License-Identifier: GPL-2.0-only
// Copyright (C) 2018 - 2021 Christian Neumanns, email: chris@pml-lang.dev

service PML_tag_info_command

    att command explicit_paiom_command<string> = explicit_paiom_command<string>.create (
        ids = [# PAIOM_command_id.create ( "tag_info" ), PAIOM_command_id.create ( "ti" ) ]
        formal_input_parameters = any_type_formal_parameters_builder.create
            .add_string_or_null_parameter (
                ids = [# "tag", "t" ]
                // allowed_values = se_PML_formal_node_registry.sorted_any_tag_list
                default_value_supplier = { null } )
            .add_string_or_null_parameter (
                ids = [# "verbosity", "v" ]
                allowed_values = [ "max", "min" ]
                default_value_supplier = { null } )
            .make_immutable
        executor = { input => se_PML_tag_info_command.execute ( input ) },
        documentation = simple_documentation.create (
            title = "PML Tags Information"
            description = null
            examples = null ) )


    function execute ( input any_type_parameters or null ) -> string

        const info = create_info ( i_input )
        OS.out.write_line ( info )
        return info
    .

    functions access:private

        function create_info ( input any_type_parameters or null ) -> string

            assert i_input is not null

            const tag = i_input.require_value<string or null> ( "tag" )

            const verbosity = i_input.require_value<string or null> ( "verbosity" ) \
                if_null: if tag =r null then "min" else "max"

            if tag is null then
                // all tags
                if verbosity =v "max" then
                    return formal_nodes_info
                else
                    return formal_nodes_summary_info
                .
            else
                const formal_node = se_PML_formal_node_registry.get_by_any_tag_or_null ( tag )
                if formal_node is null then
                    return """Tag '{{tag}}' doesn't exist.
    The following tags exist: {{se_PML_formal_node_registry.sorted_any_tag_list.to_long_string}}"""
                .

                if verbosity =v "min" then
                    return """{{formal_node.standard_tag}}, {{formal_node.documentation.title}}"""
                else
                    return """
    {{formal_node.to_long_string}}"""
                .
            .
        .

        function formal_nodes_summary_info -> string

            const builder = simple_documentation_builder.create

            builder.append_document_title ( "Summary of all tags" )

            builder.append_new_line
            builder.append_title ( "Block nodes" )
            repeat for each formal_node in se_PML_formal_node_registry.sorted_formal_nodes
                if se_formal_node.is_block_node ( formal_node ) then
                    builder.append_form_field_line (
                        label = formal_node.standard_tag, value = formal_node.documentation.title )
                .
            .

            builder.append_new_line
            builder.append_title ( "Inline nodes" )
            repeat for each formal_node in se_PML_formal_node_registry.sorted_formal_nodes is_first:is_first
                if se_formal_node.is_inline_node ( formal_node ) then
                    builder.append_form_field_line (
                        label = formal_node.standard_tag, value = formal_node.documentation.title )
                .
            .

            builder.append ( '''

To get more info about all tags, type:
pmlc tag_info -verbosity max

To get more info about a specific tag, type:
pmlc tag_info -tag [tag_name]''' )

            return se_string_constants.current_OS_new_line & builder.get_result
        .

        function formal_nodes_info -> string

            const builder = simple_documentation_builder.create

            builder.append_document_title ( "List of all tags" )

            repeat for each formal_node in se_PML_formal_node_registry.sorted_formal_nodes is_first:is_first
                builder.append_new_line
                builder.append_new_line
                builder.append ( formal_node.to_long_string )
            .

            return se_string_constants.current_OS_new_line & builder.get_result
        .
    .
.

// SPDX-License-Identifier: GPL-2.0-only
// Copyright (C) 2018 - 2021 Christian Neumanns, email: chris@pml-lang.dev


factory PML_node_creator_context

    functions

        // attribute getters

///
        get_attribute

            const r = get_attribute_or_null ( i_parameter_id )
            assert r is not null
            return r
        .

        get_attribute_or_null = a_non_HTML_attributes?.map.get_or_null ( i_parameter_id )
.///

        get_attribute_AST_or_null = a_pXML_node.attributes?.get_or_null ( name )

        get_attribute_AST

            const r = get_attribute_AST_or_null ( i_name )
            assert r is not null
            return r
        .

        get_attribute_value

            return a_non_HTML_attributes?.get_value<value> ( i_parameter_id )
        .

        get_string_attribute

            assert a_non_HTML_attributes is not null

            return a_non_HTML_attributes.get_string ( i_parameter_id )
        .

        get_string_or_null_attribute = a_non_HTML_attributes?.get_string_or_null ( i_parameter_id )

        ///
        try_get_string_attribute_or_default

            const r = a_non_HTML_attributes?.get_string_or_null ( i_parameter_id )

            if r is not null then
                return r
            else
                // TD use location of attribute name if possible
                non_canceling_error (
                    id = "ATTRIBUTE_REQUIRED"
                    info = """Attribute '{{i_parameter_id}}' is required."""
                    location = a_pXML_node.get_location )
                return i_default
            .
        .
        .///

        get_yes_no_attribute

            assert a_non_HTML_attributes is not null

            return a_non_HTML_attributes.get_yes_no ( i_parameter_id )
        .

        get_yes_no_or_null_attribute = a_non_HTML_attributes?.get_yes_no_or_null ( i_parameter_id )

        // common attributes

        get_title = get_string_attribute ( se_PML_attribute_ids.title_parameter_id )

        get_title_or_null = get_string_or_null_attribute ( se_PML_attribute_ids.title_parameter_id )

        get_id_or_null = get_string_or_null_attribute ( se_PML_attribute_ids.id_parameter_id )

        try_get_node_by_id = a_tree_context.try_get_node_by_id ( i_node_id_attribute )

        // get_node_title_or_null = i_node.attributes?.get_or_null ( se_PML_attribute_ids.title )?.value.text.to_string
        get_node_title_or_null

            const child_nodes = i_node.child_nodes?.get_list on_null:return null

            repeat for each child_node in child_nodes
                case type of child_node
                    when node__AST_node_child
                        if ( child_node.node.name.full_name =v se_PML_chapter_title_formal_node.node.standard_tag ) then
                            return child_node.node.concatenate_text_in_child_nodes
                        .
                    otherwise
                        do nothing
                .
            .
            return null
        .

        non_null_raw_text_content

            const r = a_raw_text_content
            assert r is not null
            return r
        .

        get_chapter_auto_id = a_tree_context.get_chapter_auto_id

        require_single_text_child_node

            const child_count = inline_child_nodes?.size if_null: 0
            if child_count =v 1 then
                assert inline_child_nodes is not null
                case type of inline_child_nodes.first
                    when PML_text_node text_node
                        return text_node.text
                    otherwise
                .
            .

            non_canceling_error (
                id = "NODE_CONTENT_MUST_BE_TEXT_ONLY"
                info ="""Node '{{a_pXML_node.name.full_name}}' can only contain text. It cannot contain other child nodes."""
                token = a_pXML_node.name.token )
            return "ERROR"
        .

///
        normalize_text_in_node_with_raw_text_content

            const parsed_text = require_single_text_child_node

            variable trimmed_text = remove_first_whitespace_line ( parsed_text )
            if trimmed_text is not null then
                trimmed_text = remove_last_whitespace_line ( trimmed_text )
            .

            if trimmed_text is null then
                non_canceling_error (
                    id = "NODE_CANNOT_BE_EMPTY"
                    info = """A '{{a_pXML_node.name.full_name}}' node cannot be empty. It must contain some text."""
                    token = a_pXML_node.name.token )
                return parsed_text
            .

            return remove_smallest_indent_in_all_lines_of_text ( trimmed_text )
        .
.///

        remove_smallest_indent_in_all_lines_of_text

            const without_indent = multiline_string.create ( i_text ).remove_smallest_indent_in_all_lines (
                ignore_empty_lines = yes
                ignore_whitespace_lines = yes ) on_null: return " "

            return without_indent.get_string
        .

        // error handling

        canceling_error = a_tree_context.canceling_error ( id, info, token )

        canceling_error_for_node = a_tree_context.canceling_error ( id, info, token = a_pXML_node.name.token )

        non_canceling_error
            a_tree_context.non_canceling_error ( id, info, token )
        .

        warning
            a_tree_context.warning ( id, info, token )
        .
    .

    functions access:private

///
        function remove_first_whitespace_line ( string ) -> string or null

            variable remove_count = 0
            repeat for each character in string
                if character =v ' ' or character =v '\t' or \
                    character =v '\r' then
                    remove_count = remove_count + 1
                else if character =v '\n' then
                    remove_count = remove_count + 1
                    exit repeat
                else
                    exit repeat
                .
            .

            if remove_count =v 0 then
                return i_string
            else if remove_count =v string.size then
                return null
            else
                return string.substring_from ( remove_count + 1 )
            .
        .

        function remove_last_whitespace_line ( string ) -> string or null

            variable remove_count = 0
            repeat from index = i_string.size down to 1
                const character = i_string.get ( index )
                if character =v ' ' or character =v '\t' then
                    remove_count = remove_count + 1
                else if character =v '\n' then
                    remove_count = remove_count + 1
                    exit repeat
                else
                    exit repeat
                .
            .

            if remove_count #v 0 and remove_count #v string.size then
                if i_string.get ( string.size - remove_count ) =v '\r' then
                    remove_count = remove_count + 1
                .
            .

            if remove_count =v 0 then
                return i_string
            else if remove_count =v string.size then
                return null
            else
                return string.substring_to ( string.size - remove_count )
            .
        .
.///
    .

    creator create kind:in_all
.




///
factory PML_node_creator_context

    attributes access:private
        node_ids map<key:string value:string or null> or null
        variable att chapter_counter pos_32 default: 1
        variable att current_chapter_level pos_32 default:1
        variable att keep_whitespace_in_text yes_no default:no
    .

    function get_non_HTML_attributes

        case type of se_parameters_creator.try_create_from_string_map_or_null (
            string_map = i_node_AST.non_HTML_attributes
            formal_parameters = i_node_AST.formal_node.attributes )

            when any_type_parameters r
                return r
            when null
                throw "unexpected null returned from se_parameters_creator.try_create_from_string_map"
            when parameter_errors e
                return PML_code_error.create_for_node_AST_tag (
                    info = e.info
                    i_node_AST )
        .
    .

    function get_HTML_attributes = i_node_AST.HTML_attributes

    function current_chapter_level = a_current_chapter_level

    function increase_current_chapter_level
        a_current_chapter_level = a_current_chapter_level + 1
    .

    function decrease_current_chapter_level
        a_current_chapter_level = a_current_chapter_level - 1
    .

    function get_auto_chapter_id

        const id = """ch__{{a_chapter_counter}}"""
        // TD check is unique

        a_chapter_counter = a_chapter_counter + 1

        return id
    .

    function title_of_existing_node_id

        if node_ids is not null then
            if node_ids.contains_key ( node_id ) then
                return node_ids.get ( node_id )
            .
        .
        return PML_code_error.create_for_token (
            info = """A node with id '{{i_node_id}}' doesn't exist."""
            token = id_token
            resource = i_node_AST.resource )
    .

    function create_non_empty_child_block_nodes

        const r = create_emptyable_child_block_nodes ( node_AST ) on_error: return_error
        if r is null then
            return PML_code_error.create_for_node_AST_tag (
                info = """A '{{i_node_AST.tag.value}}' node cannot be empty. It must contain at least one element."""
                i_node_AST )
        .
        return r
    .

    function create_non_empty_child_inline_nodes

        const r = create_emptyable_child_inline_nodes ( i_node_AST ) on_error: return_error
        if r is null then
            return PML_code_error.create_for_node_AST_tag (
                info = """A '{{i_node_AST.tag.value}}' node cannot be empty. It must contain at least one element."""
                i_node_AST )
        .
        return r
    .

    function create_emptyable_child_block_nodes

        const child_nodes_AST = i_node_AST.child_nodes on_null:return null

        const block_nodes = mutable_list<PML_block_node>.create

        variable index = 1

        repeat while index <= child_nodes_AST.size
            const child_node_AST = child_nodes_AST.get ( index )

            const formal_child_node = child_node_AST.formal_node
            if se_formal_node.is_block_node ( formal_child_node ) then
                const node = formal_child_node.node_creator.create_node ( node_AST = child_node_AST, context = this ) \
                    on_error: return_error
                const n PML_block_node = node type_check:no
                block_nodes.append ( n )
                index = index + 1
            else
                const new_index = append_paragraphs (
                    block_nodes, child_nodes_AST, start_index = index ) on_error:return_error
                index = new_index
            .
        .

        return block_nodes.make_immutable_or_null
    .

    function create_emptyable_child_inline_nodes

        const child_nodes_AST = i_node_AST.child_nodes on_null:return null

        const inline_nodes = mutable_indexed_list<PML_inline_node>.create

        repeat for each child_node_AST in child_nodes_AST

            const formal_child_node = child_node_AST.formal_node
            if se_formal_node.is_inline_node ( formal_child_node ) then
                if formal_child_node =r se_PML_standard_formal_nodes.text then
                    const text = child_node_AST.raw_text_content?.value
                    assert text is not null
                    append_text_node ( inline_nodes, text )
                else
                    append_inline_node ( inline_nodes, node_AST = child_node_AST, formal_node = formal_child_node ) \
                        on_error: return_error
                .
            else
                return PML_code_error.create_for_node_AST_tag (
                    info = """A '{{i_node_AST.tag.value}}' node (defined at {{i_node_AST.tag.position.to_string}}) cannot contain a '{{child_node_AST.tag.value}}' node, because '{{i_node_AST.tag.value}}' nodes can only contain inline nodes, but '{{child_node_AST.tag.value}}' is not an inline node (it is a block node)."""
                    node_AST = child_node_AST )
            .
        .

        return inline_nodes.make_immutable_or_null
    .

    function require_single_text_child_node

        const content = create_non_empty_child_inline_nodes ( i_node_AST ) on_error: return_error
        if content.size =v 1 then
            case type of content.first
                when PML_text_node text_node
                    return text_node
                otherwise
            .
        .
        return PML_code_error.create_for_node_AST_tag (
            info ="""Node '{{i_node_AST.tag.value}}' can only contain text. It cannot contain other child nodes."""
            i_node_AST )
    .

    function set_keep_whitespace_in_text

        a_keep_whitespace_in_text = i_value
    .

    function normalize_text_in_node_with_raw_text_content

        const parsed_text = i_node_AST.raw_text_content?.value
        assert parsed_text is not null

        variable trimmed_text = remove_first_whitespace_line ( parsed_text )
        if trimmed_text is not null then
            trimmed_text = remove_last_whitespace_line ( trimmed_text )
        .

        if trimmed_text is null then
            return PML_code_error.create_for_node_AST_tag (
                info = """A '{{i_node_AST.tag.value}}' node cannot be empty. It must contain some text."""
                i_node_AST )
        .

        return remove_smallest_indent_in_all_lines_of_text ( trimmed_text )
    .

    function remove_smallest_indent_in_all_lines_of_text

        const without_indent = multiline_string.create ( i_text ).remove_smallest_indent_in_all_lines (
            ignore_empty_lines = yes
            ignore_whitespace_lines = yes ) on_null: return " "

        return without_indent.get_string
    .

///
    function find_smallest_indent_in_text_child_nodes

//        const r string or null = null
//        repeat for each
//        return smallest_indent_in_text_node ( i_parent_node )

        return smallest_indent_in_child_nodes ( i_parent, current_smallest = null )
    .

    function remove_first_line_indent_in_all_text_nodes

        return i_node_AST
    .
.///

    functions access:private

///
        function smallest_indent_in_child_nodes ( parent PML_node_AST, current_smallest string or null ) \
            -> string or null

            if parent.child_nodes as child_nodes is null then
                return i_current_smallest
            else
                variable r = i_current_smallest
                repeat for each node in child_nodes

                    ///
                    const smallest_indent_in_node = smallest_indent_in_text_node ( node )
                    r = smallest_indent ( indent_1 = r, indent_2 = smallest_indent_in_node )
                    .///

                    r = smallest_indent_with_text_node ( node, i_current_smallest )

                    const smallest_indent_in_children = smallest_indent_in_child_nodes (
                        parent = node
                        current_smallest = r )
                    r = smallest_indent ( indent_1 = r, indent_2 = smallest_indent_in_children )
                .
                return r
            .
        .

        function smallest_indent_with_text_node ( node PML_node_AST, current_smallest string or null ) -> string or null

            if not i_node.is_text_node then
                return i_current_smallest
            .

            const text = i_node.raw_text_content?.value
            assert text is not null

            // ignore text that doesn't contain line breaks
            if not text.contains_character ( '\n' ) then
                return i_current_smallest
            .

            const node_indent = multiline_string.create ( text ).find_smallest_indent ( ignore_empty_lines = yes )
            const r = smallest_indent ( indent_1 = i_current_smallest, indent_2 = node_indent )

            return r
        .

        function smallest_indent ( indent_1 string or null, indent_2 string or null ) -> string or null

            if indent_1 is null then
                return indent_2
            .

            if indent_2 is null then
                return indent_1
            .

            return if indent_1.size <# indent_2.size \
                then indent_1 \
                else indent_2
        .
.///

        function append_paragraphs -> pos_32 or anticipated_error
            in block_nodes mutable_list<PML_block_node>
            in child_nodes_AST indexed_list<PML_node_AST>
            in start_index pos_32

            variable inline_nodes = mutable_indexed_list<PML_inline_node>.create

            variable index = start_index
            repeat while index <= i_child_nodes_AST.size
                const child_node_AST = i_child_nodes_AST.get ( index )

                const formal_child_node = child_node_AST.formal_node
                if se_formal_node.is_block_node ( formal_child_node ) then
                    exit repeat
                .

                if formal_child_node =r se_PML_standard_formal_nodes.text then
                    const text = child_node_AST.raw_text_content?.value
                    assert text is not null

                    // Two consecutive new lines are treated as a paragraph break

                    const texts = text.split_by_regex ( se_PML_node_creator_regexes.paragraph_break )

                    if texts.first as first_text is not null then
                        append_text_node ( inline_nodes, text = first_text )
                    .

                    if texts.size ># 1 then
                        append_paragraph ( block_nodes, inline_nodes )

                        if texts.size >= 3 then
                            repeat from mid_index = 2 to texts.size - 1
                                if texts.get ( mid_index ) as mid_text is not null then
                                    const singleton_inline_nodes = mutable_indexed_list<PML_inline_node>.create
                                    append_text_node (
                                        inline_nodes = singleton_inline_nodes
                                        text = mid_text )
                                    append_paragraph (
                                        block_nodes,
                                        inline_nodes = singleton_inline_nodes )
                                else
                                    append_paragraph ( block_nodes, inline_nodes )
                                    inline_nodes = mutable_indexed_list<PML_inline_node>.create
                                .
                            .
                        .

                        inline_nodes = mutable_indexed_list<PML_inline_node>.create
                        if texts.last as last_text is not null then
                            append_text_node ( inline_nodes, text = last_text )
                        .
                    .

                else
                    append_inline_node ( inline_nodes, node_AST = child_node_AST, formal_node = formal_child_node ) \
                        on_error: return_error
                .

                index = index + 1
            .

            append_paragraph ( block_nodes, inline_nodes )

            return index
        .

        function append_paragraph
            in block_nodes mutable_list<PML_block_node>
            in inline_nodes mutable_indexed_list<PML_inline_node>

            if inline_nodes.is_empty then
                return
            .

            // remove space at end of paragraph
            case type of inline_nodes.last
                when PML_text_node text_node
                    const text = text_node.text
                    if text.ends_with ( " " ) then
                        if text.size =v 1 then
                            inline_nodes.remove_last
                            if inline_nodes.is_empty then
                                return
                            .
                        else
                            inline_nodes.replace_last ( PML_text_node.create ( text.remove_last ) )
                        .
                    .
                otherwise
                    do nothing
            .

            const paragraph = PML_paragraph_node.create (
                node_id = null, title = null, HTML_attributes = null, child_nodes = inline_nodes.make_immutable )
            block_nodes.append ( paragraph )
        .

        function append_inline_node -> anticipated_error or null
            in inline_nodes mutable_indexed_list<PML_inline_node>
            in node_AST PML_node_AST
            in formal_node PML_formal_node<*>

            const node = formal_node.node_creator.create_node ( node_AST, context = this ) on_error: return_error
            const n PML_inline_node = node type_check:no
            inline_nodes.append ( n )
            return null
        .

        function append_text_node
            in inline_nodes mutable_indexed_list<PML_inline_node>
            in text string

            const trimmed_text = if a_keep_whitespace_in_text \
                then i_text \
                else trim_whitespace_in_text ( i_text, is_first_node = inline_nodes.is_empty )
            if trimmed_text is null then
                return
            .

            inline_nodes.append ( PML_text_node.create ( se_PML_code.unescape_text ( trimmed_text ) ) )
        .

        function trim_whitespace_in_text ( text string, is_first_node yes_no ) -> string or null

            // replace sequences of whitespace with one space
            variable trimmed_text = i_text.replace_all_regex (
                to_replace = se_PML_tokenizer_config_default_values.whitespace
                replace_by = " " )

            if i_is_first_node then
                if trimmed_text.starts_with ( " " ) then
                    if trimmed_text.size =v 1 then
                        return null
                    .
                    trimmed_text = trimmed_text.remove_first
                .
            .

            return trimmed_text
        .

        function remove_first_whitespace_line ( string ) -> string or null

            variable remove_count = 0
            repeat for each character in string
                if character =v ' ' or character =v '\t' or \
                    character =v '\r' then
                    remove_count = remove_count + 1
                else if character =v '\n' then
                    remove_count = remove_count + 1
                    exit repeat
                else
                    exit repeat
                .
            .

            if remove_count =v 0 then
                return i_string
            else if remove_count =v string.size then
                return null
            else
                return string.substring_from ( remove_count + 1 )
            .
        .

        function remove_last_whitespace_line ( string ) -> string or null

            variable remove_count = 0
            repeat from index = i_string.size down to 1
                const character = i_string.get ( index )
                if character =v ' ' or character =v '\t' then
                    remove_count = remove_count + 1
                else if character =v '\n' then
                    remove_count = remove_count + 1
                    exit repeat
                else
                    exit repeat
                .
            .

            if remove_count #v 0 and remove_count #v string.size then
                if i_string.get ( string.size - remove_count ) =v '\r' then
                    remove_count = remove_count + 1
                .
            .

            if remove_count =v 0 then
                return i_string
            else if remove_count =v string.size then
                return null
            else
                return string.substring_to ( string.size - remove_count )
            .
        .
    .

    creator create -> PML_node_creator_context
        in node_ids map<key:string value:string or null> or null

        this.node_ids = i_node_ids

        return this
    .
.
.///